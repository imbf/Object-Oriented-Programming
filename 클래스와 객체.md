# 클래스와 객체

## 4.1 객체 지향과 자바

### 세상의 모든 것이 객체

우리 주변에 있는 모든 것이 객체이다. 

실세계의 객체들은 자신만의 고유한 **특성(state)**과 **행동(behavior)**을 가지며 다른 객체들에게 행동을 요청하거나 정보를 주고받는 등 상호작용하면서 존재한다.

### 객체 지향 언어의 특성

- **캡슐화(Encapsulation)**

   - <u>객체를 캡슐로 싸서 내부를 보호하고 볼 수 없게 하는 것</u>으로 객체의 가장 본질적인 특징이다.
   - 객체는 캡슐화가 기본 원칙이지만 외부와의 접속을 위해 몇 부분만 **공개 노출**한다.
   - 자바에서는 **클래스(class)**라는 캡슐을 사용하며, **필드(멤버 변수)**와 **메소드(멤버 함수)**로 구성된다.

   ```java
   class Animal{
     String name;
     int age;
     void eat() {...}
     void spaek() {...}
     void love() {...}
   }
   ```

- **상속(Inheritance)**

   - 자바의 상속은 자식 클래스가 부모 클래스의 속성을 물려받고 기능을 추가하여 **확장(extends)**하는 개념이다.
   - 자바에서 부모 클래스를 **슈퍼 클래스(super class)**라고 부르며 자식 클래스를 **서브 클래스(sub class)**라고 부른다.
   - 상속은 슈퍼 클래스의 필드와 메소드를 물려받아 코드를 재사용함으로써, 코드 작성에 드는 시간과 비용을 줄인다.

   ```java
   class Animal{
     String name;
     int age;
     void eat() {...}
     void spaek() {...}
     void love() {...}
   }
   
   // 서브 클래스인 Human 객체는 슈퍼 클래스인 Animal의 멤버와 서브 클래스의 멤버를 모두 가짐
   class Human extends Animal{
     String hobby;
     String job;
     void work() {...}
     void cry() {...}
     void laugh() {...}
   }
   ```

- **다형성(Polymorphism)**

   - 다형성은 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 동작하도록 구현되는 것을 말한다.
   - **메소드 오버라이딩(overriding)** : 슈퍼 클래스에 구현된 메소드를, 서브 클래스에서 동일한 이름으로 자신의 특징에 맞게 다시 구현하는 기법
   - **메소드 오버로딩(overloading)** : 클래스 내에서 이름이 같지만 서로 다르게 동작하는 메소드를 여러 개 만드는 기법

### 객체 지향 언어의 목적

- 소프트웨어 생산성 향상
- 실세계에 대한 쉬운 모델링

객체 지향 개념은 프로그램을 보다 실제 세상에 가깝게 모델링(modeling)하여 실제 세상의 물체를 객체로 표현하고, 객체들의 관계, 상호 작용을 설계한 뒤, 각 객체를 클래스로 작성하면 프로그램이 완성된다.

---

## 4.2 자바 클래스 만들기

### 클래스와 객체

**클래스(Class)** : 객체를 만들어 내기 위한 설계도 혹은 틀

**객체(Object) :** 클래스 모양 그대로 생성된 실체를 의미한다. == (클래스의 인스턴스)

**클래스는 하나지만 객체들은 수 없이 많이 생성될 수 있다.**

### 클래스 구성

- **클래스 선언** : **class 키워드**와 클래스 이름으로 선언하고 중괄호({}) 안에 **필드(field)**와 **메소드(method)**를 모두 작성한다.
   클래스 외부에는 캡슐화의 원칙에 따라 어떤 필드나 메소드를 둘 수 없다.
- **필드와 메소드** : 객체 내에 값을 저장할 멤버 변수를 **필드**라고 부른다. **메소드**는 함수이며 객체의 행동을 구현한다.
- **접근 지정자** 
- **생성자(constructor)** : 클래스의 이름과 동일한 메소드를 생성자라고 한다. 객체가 생성될 때 자동으로 호출되는 메소드

### new 연산자와 객체 생성, 그리고 레퍼런스 변수

```java
public static void main(String[] args){
  Circle pizza;											//Circle 객체에 대한 레퍼런스 변수 pizza 선언 및 null로 초기화
  pizza = new Circle();							//Circle 객체 생성 및 메모리 할당
  
  pizza.radius = 10;								//radius 필드에 10 저장
  pizza.name = "자바피자";						//name 필드에 "자바피자" 저장
  double area = pizza.getArea();		//pizza 객체의 면적 알아내기
}
```

**new 연산자에 의해 객체가 생성되는 과정**

- 클래스 타입 크기의 메모리 할당
- 클래스의 생성자 코드 실행

---

## 4.3 생성자(constructor)

### 생성자의 개념과 목적

**생성자(constructor)**는 객체가 생성될 때 **객체의 초기화**를 위해 실행되는 메소드이다.

### 생성자 선언 및 활용

- 생성자는 객체가 생성되는 순간에 **자동으로 호출**되는 메소드로서 객체에 필요한 초기화를 실행하는 코드를 담아야 한다.

- **생성자의 이름은 클래스의 이름과 동일하다.**
- **생성자는 여러 개 작성(오버로딩)할 수 있다.**
   매개변수의 개수와 타입만 다르다면, 클래스 내에 생성자를 여러 개 둘 수 있다.
- **생성자는 new를 통해 객체를 생성할 때 한 번만 호출된다.**
   객체 생성은 반드시 new를 통해서만 이루어지며, 생성자는 이 때 자동으로 한번만 호출된다.
- **생성자에 리턴 타입을 지정할 수 없다.** (return문은 사용 가능하다.)
- **생성자의 목적은 객체가 생성될 때, 필요한 초기 작업을 위함이다.**

이렇게 생성자는 객체가 생성될 때, <u>필드 초기화, 필요한 메모리 확보, 파일 열기, 네트워크 연결</u> 등 객체가 활동하기 전에 필요한 초기 준비를 하는데 이용된다.

### 기본 생성자

기본 생성자란 매개변수와 실행 코드가 없어 아무 일도 하지 않고 단순 리턴하는 생성자이다. **디폴트 생성자**라고도 부른다.

- 기본 생성자가 자동으로 생성되는 경우 : 생성자가 하나도 없는 경우, 컴파일러는 기본 생성자를 자동으로 생성한다.
- 기본 생성자가 자동으로 생성되지 않는 경우 : 생성자가 하나라도 존재하는 클래스에는 컴파일러가 기본생성자를 자동으로 삽입해 주지 않는다.

### this 레퍼런스

- **this의 기초 개념**

   **this는 현재 객체 자신에 대한 <u>레퍼런스</u>이다.** 보다 정확히 말하면 현재 실행되고 있는 메소드가 속한 객체에 대한 레퍼런스이다. 

- **this의 필요성**

   ```java
   class Circle{
     int radius;
     public Circle(int radius){
       this.radius = radius
     }
   }
   ```

- **객체 자신의 레퍼런스를 리턴해야 하는 경우**

   ```java
   class Circle{
     public Circle getMe(){		//getMe() 메소드는 객체 자신의 레퍼런스를 리턴한다.
       return this;	
     }
   }
   ```

### this()로 다른 생성자 호출

**this()는 클래스 내에서 생성자가 다른 생성자를 호출할 때 사용하는 자바 코드이다.**

- **this() 사용시 주의할 점**
   - this()는 반드시 생성자 코드에서만 호출할 수 있다.
   - this()는 반드시 같은 클래스 내 다른 생성자를 호출할 때 사용된다.
   - this()는 반드시 생성자의 첫 번째 문장이 되어야 한다.

### 객체 치환 시 주의할 점

아무도 가리키지 않는 객체는 **가비지(garbage)**라고 부르며, 가비지는 자바 가상 기계에 의해 자동으로 수거되어 재사용된다.

---

## 4.4 객체 배열

### 객체 배열

자바에서 기본 타입 데이터 뿐 아니라 객체를 원소로 하는 객체 배열도 만들 수 있다.

자바의 **객체 배열**은 **객체에 대한 레퍼런스를 원소로 갖는 배열**이다.

```java
Circle [] c;							//Circle 배열에 대한 레퍼런스 변수 c 선언
c = new Circle[5];				//레퍼런스 배열 생성

for(int i=0;i<c.length;i++)
  c[i] = new Circle(i);		// 배열의 각 원소 객체 생성
```

### 배열 선언 및 생성

1. 배열에 대한 레퍼런스 선언

   ```java
   Circle [] c;
   ```

2. 레퍼런스 배열 생성

   ```java
   c = new Circle[5];	// Circle 객체에 대한 레퍼런스 5개 생성
   ```

3. 객체 생성

4. 객체 사용

---

## 4.5 메소드 활용

### 메소드 형식

**메소드**는 **클래스의 멤버 함수**로서, 메소드 앞에 접근 지정자를 선언한다는 점을 제외하면 C / C++의 함수 작성법과 동일하다.
접근 지정자는 **public, private, protected, 디폴트**의 4가지 유형으로, 메소드가 다른 클래스에서 호출될 수 있는지 지정하기 위해 사용된다.

```java
public int getSum(int i, int j){
  int sum;
  sum = i + j;
  return sum;
}
```

### 인자 전달

자바의 메소드 호출 시 인자 전달 방식(argument passing)은 '**값에 의한 호출(call-by-value)**'이다.
호출하는 실인자의 값이 복사되어 **메소드의 매개 변수에** 전달된다.

- **기본 타입의 값이 전달되는 경우**
   메드의 매개변수가 기본 타입(byte, char, short, int, long, float, double, boolean)으로 선언된 경우, **호출자(caller)**가 건네는 **값이 매개변수에 복사되어** 전달된다.

- **객체가 전달되는 경우**
   메소드의 매개변수가 클래스 타입의 경우, 객체가 아니라 **객체의 레퍼런스 **값이 전달된다.

   ```java
   class Circle{
     int radius;
   }
   public class ReferencePassing{
     static void increase(Circle m){
       m.radius++;
     }
     public static void main(String[] args){
       Circle pizza = new Circle(10);
       
       increase(pizza);	
       
       System.out.println(pizza.radius);
     }
   }
   /*
   호출하는 매개변수 m이 생기고, pizza 변수에 저장된 값(레퍼런스) 이 m에 복사되어, m은 pizza가 가리키는 객체를 
   함께 가리키게 된다.
   */
   ```

   메소드 호출 시 객체가 전달되는 경우, **객체에 대한 레퍼런스만 전달**되지 객체가 통째로 복사되지 않는다는 점을 유념!!

- **배열이 전달되는 경우**
   배열이 메소드에 전달되는 경우도 객체 레퍼런스가 전달되는 경우와 동일하다. 배열이 통째로 전달되는 것이 아니라
   **배열에 대한 레퍼런스**만 전달된다.

**자바에서는 메소드의 매개변수로 객체나 배열을 전달할 때 레퍼런스만 전달하기 때문에, 객체나 배열이 통째로 넘어가지 않는다.**

### 메소드 오버로딩(Method Overloading)

자바에서는 한 클래스 내에, 이름이 같지만 매개변수의 타입이나 개수가 서로 다른 여러 개의 메소드를 중복 작성할 수 있다.
이것을 **메소드 오버로딩(method overloading)** 혹은 메소드 중복이라고 부른다. 메소드 오버로딩은 **자바의 다형성의 한 경우**이다. 메소드 오버로딩은 자바 컴파일러에 의해 판단된다.

**메소드 오버로딩 만족 조건**

1. **메소드 이름이 동일하여야 한다.**
2. **매개변수의 개수나 타입이 서로 달라야 한다.**

**메소드의 리턴 타입이나 접근 지정자는 메소드 오버로딩과 관계 없다.** (호출자의 입장에서 구분할 수 없다.)

```java
// 메소드 오버로딩 성공 사례(메소드 이름이 동일하고 매개변수의 개수가 서로 다름)
class methodOverloading{
  public int getSum(int i, int j){
    return i + j;
  }
  public int getSum(int i, int j, int k){
    return i + j + k;
  }
}

// 메소드 오버로딩 실패 사례 (접근 지정자는 메소드 오버로딩과 관련이 없다.)
class MethodOverloadingFail{
  public int getSum(int i, int j){
    return i + j;
  }
  public double getSum(int i, int j){
    return (double)(i + j);
  }
}
```

---

## 4.6 객체의 소멸과 가비지 컬렉션

### 객체의 소멸

**자바에서는 개발자가 마음대로 객체를 소멸시킬 수 없다.**(즉, 메모리 관리 불가하다.)

**객체 소멸** : new에 의해 생성된 객체 공간을 자바 가상 기계에게 돌려주어 가용 메모리(available memory)에 포함시키는 것

**가비지(garbage)** : 자바에서 new로 할당받은 후 사용하지 않게 된 객체 메모리

자바 가상 기계의 **가비지 컬렉터(garbage collector)**가 **가비지**를 적절한 시점에 자동으로 수집하여 **가용 메모리에 반환**시킨다.

### 가비지(garbage)

**가비지(garbage)**란 자바 응용프로그램에서 더 이상 사용되지 않게 된 객체나 배열 메모리이다. 즉, 참조하는 레퍼런스가 하나도 없는 객체나 배열을 가비지로 판단한다.

### 가비지 컬렉션(garbage collection)

자바 플랫폼은 가용 메모리가 일정 크기 이하로 줄어들면 자동으로 가비지를 회수하여 가용 메모리를 늘린다. 이것을 **가비지 컬렉션**이라고 부르며, 가비지 컬렉션은 자바 플랫폼에 의해 준비된 **가비지 컬렉션 스레드(garbage collection thread)**에 의해 처리된다. 가비지 컬렉션 때문에 응용 프로그램이 종종 멈추기도 하기 때문에 자바는 실시간 처리 응용에는 부적합한 것으로 알려져 있다.

### 가비지 컬렉션 강제 요청

응용프로그램에서 **System** 또는 **Runtime** 객체의 **gc() 메소드**를 호출하면 가비지 컬렉션을 요청할 수 있다.

```java
System.gc();	// 가비지 컬렉션 강제 요청
```

이 문장을 호출한 즉시 가비지 컬렉터가 작동하는 것은 아니다. 이 문장은 가비지 컬렉션이 필요하다는 요청에 불과하다. 가비지 컬렉션은 자바 플랫폼이 전적으로 판단하여 적절한 시점에 작동시킨다.

---

## 4.7 접근 지정자(Access Specifier)

객체 지향 언어에는 **접근 지정자**를 두고 있다. 객체를 **캡슐화**하기 때문에, 객체에 다른 객체가 접근하는 것으로 허용할지, 말지를 지정할 필요가 있기 때문이다.

### 패키지(package)

자바는 서로 관련 있는 클래스 파일들을 **패키지(package)**에 저장하여 관리하도록 한다. 패키지는 **디렉터리 혹은 폴더**와 같은 
개념이다.

### 자바의 4가지 접근 지정자

접근 지정자(access specifier)는 클래스나 멤버들을 다른 클래스에서 접근해도 되는지의 여부를 선언하는 지시어이다.

**private, protected, public, 접근 지정자 생략(디폴트 접근 지정)** 들이 있다.

### 클래스 접근 지정

다른 클래스에서 이 클래스를 활용할 수 있는지 허용 여부를 지정하는 것으로 말한다.

- **public 클래스**
   클래스 이름 앞에 public으로 선언된 클래스로서, **패키지에 상관없이 다른 어떤 클래스에게도 사용이 허용된다.**

   ```java
   public class World{	// public 클래스
     ........
   }
   ```

- **디폴트 클래스(접근 지정자 생략)**
   접근 지정자 없이 클래스를 선언한 경우, 디폴트(default) 접근 지정으로 선언되었다고 한다.
   **디폴트 클래스는 같은 패키지 내의 클래스들에게만 사용이 허용된다.**

   ```java
   class Local{	// 디폴트 클래스
     .......
   }
   ```

- **protected 접근지정자는 class와 interface의 접근 지정자로 사용할 수 없다.**
   **interface의 method와 fields에 interface접근 지정자를 사용할 수 없다.**

- **privat 접근지정는 class와 interface의 접근지정자로 사용할 수 없다.**
   private 접근지정자는 객체의 캡슐화와 외부 세계로부터의 data를 숨기기 위해 사용한다.

### 멤버 접근 지정

- **public 멤버**
   **public 멤버는 패키지를 막론하고 모든 클래스들이 접근 가능하다.**
- **private 멤버**
   private 접근 지정자는 비공개를 지시하는 것으로, **private 멤버는 클래스 내의 멤버들에게만 접근이 허용된다.**
- **protected 멤버**
   protected 접근 지정자는 보호된 공개를 지시하는 것으로, 2가지 유형의 클래스에만 접근을 허용한다.
   첫째. **같은 패키지의 모든 클래스에 접근이 허용된다.** 둘째. **다른 패키지에 있더라도 자식클래스의 경우 접근이 허용된다.**
- **디폴트 멤버(default 또는 package-private)**
   접근 지정자가 생략된 멤버의 경우, 디폴트(default) 멤버라고 한다. **동일한 패키지 내에 있는 클래스들만 디폴트 멤버를 자유롭게 접근할 수 있다.**

---

## 4.8 static 멤버

### non-static 멤버와 static 멤버의 차이점

**static 멤버는 객체를 생성하지 않고도 사용할 수 있는 멤버이다.** **static 멤버는 클래스당 하나만 생성되는 멤버로서 동일한 클래스의 모든 객체들이 공유한다.** **그리고 main()메소드가 실행되기 전에 이미 생성된다. static 멤버는 static 멤버가 포함된 객체를 생성하기 전에도 사용할 수 있다.**

#### **static 멤버 **

- **선언**

   ```java
   class Sample{
     static int m;
     static void g() {...}
   }
   ```

- **공간적 특성(멤버는 클래스당 하나 생성)**

   - 멤버는 객체 내부가 아닌 별도의 공간(**클래스 코드가 적재되는 메모리**)에 생성
   - 클래스 멤버라고 부름

- **시간적 특성(클래스 로딩 시에 멤버 생성)**

   - 객체가 생기기 전에 이미 생성
   - 객체가 생기기 전에도 사용 가능
   - 객체가 사라져도 멤버는 사라지지 않ㅇ므
   - 멤버는 프로그램이 종료될 때 사라짐

- **공유의 특성** : 동일한 클래스의 **모든 객체들에 의해** 공유됨

#### **non static 멤버**

- **선언**

   ```java
   class Sample{
     int n;
     void g() {...}
   }
   ```

- **공간적 특성(멤버는 객체마다 별도 존재)**

   - 인스턴스 멤버라고 부름

- **시간적 특성(객체 생성 시에 멤버 생성됨)**

   - 객체가 생길 때 멤버도 생성
   - 객체 생성 후 멤버 사용 가능
   - 객체가 사라지면 멤버도 사라짐

- **공유의 특성(공유되지 않음)**

   - 멤버는 객체 내에 각각 공간 유지

### static 멤버의 생성 및 활용 : 클래스명.static 멤버

static 멤버는 클래스당 하나만 있기 때문에 **클래스 이름**으로 바로 접근할 수 있다. **new에 의해 객체가 생기기전에도 접근 가능**

```java
클래스명.static멤버
```

### static의 활용

자바에서는 캡슐화 원칙에 따라 어떤 변수나 함수도 클래스 바깥에 존재할 수 없으며 클래스의 멤버로 존재하여야 한다.

하지만 응용 프로그램 작성 시 모든 클래스에서 공유하는 **전역 변수(global variable)**나 모든 클래스에서 호출할 수 있는 

**전역 함수(global function)**가 필요한 경우가 있다. **static은 이런 문제에 대한 해결책이다.**

예로들어 static 멤버를 가진 대표적인 클래스로 java.lang.Math 클래스가 있다.

```java
public class Math{
  public static int abs(int a);
  public static double cos(double a);
  public static int max(int a, int b);
  public static double random();
}
```

**공유 멤버를 만들고자 할 때 활용한다.**

### static 메소드의 제약 조건

- **static 메소드는 static 멤버만 접근할 수 있다.**
   static 메소드는, 객체 없이도 존재하기 때문에, 객체와 함께 생성되는 non-static멤버를 사용할 수 없고 **static 멤버들만 사용 가능** 반면 non-static 메소드는 static 멤버들을 사용할 수 있다.
- **static 메소드는 this를 사용할 수 없다.**

---

## 4.9 final

### final 클래스

**final**이 클래스 이름 앞에 사용되면 **클래스를 상속받을 수 없다.**

```java
final class FinalClass{	// 이 클래스는 상속 불가
  ...
}
class SubClass extends FinalClass{	// 컴파일 오류 발생. FinalClass 상속 불가
  ...
}
```

### final 메소드

**final**로 메소드를 선언하면 **오버라이딩할 수 없는 메소드**임을 선언한다.
자식 클래스가 부모 클래스의 특정 메소드를 오버라이딩하지 못하게 하고 무조건 상속받아 사용하도록 하고자 한다면 final로
필드를 지정하면 된다.

```java
public class SuperClass{
  protected final int finalMethod(){...}	//finalMethod()는 자식이 오버라이딩 불가하다.
}
class SubClass extends SuperClass{				// SubClass가 SuperClass 상속
  protected int finalMethod() {...}				// 컴파일 오류. finalMethod()는 final Method라 오버라이딩
																					// 안된다.
}
```

### final 필드

final로 필드를 선언하면 필드는 상수가 된다. 상수 필드는 한 번 초기화되면 값을 변경할 수 없다.
final 키워드를 public static과 함께 선언하면, 프로그램 전체에서 사용할 수 있는 상수가 된다.

```java
public class FinalFieldClass{
  final int ROWS = 10;							// 상수 선언. 초기값(10) 지정
  void f(){
    int[] intArray = new int[ROWS];	// 상수 활용
    ROWS = 30;											// 컴파일 오류. final 필드 값은 변경할 수 없다.
  }
}
```

















