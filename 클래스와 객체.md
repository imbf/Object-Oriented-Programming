# 클래스와 객체

## 4.1 객체 지향과 자바

### 세상의 모든 것이 객체

우리 주변에 있는 모든 것이 객체이다. 

실세계의 객체들은 자신만의 고유한 **특성(state)**과 **행동(behavior)**을 가지며 다른 객체들에게 행동을 요청하거나 정보를 주고받는 등 상호작용하면서 존재한다.

### 객체 지향 언어의 특성

- **캡슐화(Encapsulation)**

   - <u>객체를 캡슐로 싸서 내부를 보호하고 볼 수 없게 하는 것</u>으로 객체의 가장 본질적인 특징이다.
   - 객체는 캡슐화가 기본 원칙이지만 외부와의 접속을 위해 몇 부분만 **공개 노출**한다.
   - 자바에서는 **클래스(class)**라는 캡슐을 사용하며, **필드(멤버 변수)**와 **메소드(멤버 함수)**로 구성된다.

   ```java
   class Animal{
     String name;
     int age;
     void eat() {...}
     void spaek() {...}
     void love() {...}
   }
   ```

- **상속(Inheritance)**

   - 자바의 상속은 자식 클래스가 부모 클래스의 속성을 물려받고 기능을 추가하여 **확장(extends)**하는 개념이다.
   - 자바에서 부모 클래스를 **슈퍼 클래스(super class)**라고 부르며 자식 클래스를 **서브 클래스(sub class)**라고 부른다.
   - 상속은 슈퍼 클래스의 필드와 메소드를 물려받아 코드를 재사용함으로써, 코드 작성에 드는 시간과 비용을 줄인다.

   ```java
   class Animal{
     String name;
     int age;
     void eat() {...}
     void spaek() {...}
     void love() {...}
   }
   
   // 서브 클래스인 Human 객체는 슈퍼 클래스인 Animal의 멤버와 서브 클래스의 멤버를 모두 가짐
   class Human extends Animal{
     String hobby;
     String job;
     void work() {...}
     void cry() {...}
     void laugh() {...}
   }
   ```

- **다형성(Polymorphism)**

   - 다형성은 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 동작하도록 구현되는 것을 말한다.
   - **메소드 오버라이딩(overriding)** : 슈퍼 클래스에 구현된 메소드를, 서브 클래스에서 동일한 이름으로 자신의 특징에 맞게 다시 구현하는 기법
   - **메소드 오버로딩(overloading)** : 클래스 내에서 이름이 같지만 서로 다르게 동작하는 메소드를 여러 개 만드는 기법

### 객체 지향 언어의 목적

- 소프트웨어 생산성 향상
- 실세계에 대한 쉬운 모델링

객체 지향 개념은 프로그램을 보다 실제 세상에 가깝게 모델링(modeling)하여 실제 세상의 물체를 객체로 표현하고, 객체들의 관계, 상호 작용을 설계한 뒤, 각 객체를 클래스로 작성하면 프로그램이 완성된다.

---

## 4.2 자바 클래스 만들기

### 클래스와 객체

**클래스(Class)** : 객체를 만들어 내기 위한 설계도 혹은 틀

**객체(Object) :** 클래스 모양 그대로 생성된 실체를 의미한다. == (클래스의 인스턴스)

**클래스는 하나지만 객체들은 수 없이 많이 생성될 수 있다.**

### 클래스 구성

- **클래스 선언** : **class 키워드**와 클래스 이름으로 선언하고 중괄호({}) 안에 **필드(field)**와 **메소드(method)**를 모두 작성한다.
   클래스 외부에는 캡슐화의 원칙에 따라 어떤 필드나 메소드를 둘 수 없다.
- **필드와 메소드** : 객체 내에 값을 저장할 멤버 변수를 **필드**라고 부른다. **메소드**는 함수이며 객체의 행동을 구현한다.
- **접근 지정자** 
- **생성자(constructor)** : 클래스의 이름과 동일한 메소드를 생성자라고 한다. 객체가 생성될 때 자동으로 호출되는 메소드

### new 연산자와 객체 생성, 그리고 레퍼런스 변수

```java
public static void main(String[] args){
  Circle pizza;											//Circle 객체에 대한 레퍼런스 변수 pizza 선언 및 null로 초기화
  pizza = new Circle();							//Circle 객체 생성 및 메모리 할당
  
  pizza.radius = 10;								//radius 필드에 10 저장
  pizza.name = "자바피자";						//name 필드에 "자바피자" 저장
  double area = pizza.getArea();		//pizza 객체의 면적 알아내기
}
```

**new 연산자에 의해 객체가 생성되는 과정**

- 클래스 타입 크기의 메모리 할당
- 클래스의 생성자 코드 실행

---

## 4.3 생성자(constructor)

### 생성자의 개념과 목적

**생성자(constructor)**는 객체가 생성될 때 **객체의 초기화**를 위해 실행되는 메소드이다.

### 생성자 선언 및 활용

- 생성자는 객체가 생성되는 순간에 **자동으로 호출**되는 메소드로서 객체에 필요한 초기화를 실행하는 코드를 담아야 한다.

- **생성자의 이름은 클래스의 이름과 동일하다.**
- **생성자는 여러 개 작성(오버로딩)할 수 있다.**
   매개변수의 개수와 타입만 다르다면, 클래스 내에 생성자를 여러 개 둘 수 있다.
- **생성자는 new를 통해 객체를 생성할 때 한 번만 호출된다.**
   객체 생성은 반드시 new를 통해서만 이루어지며, 생성자는 이 때 자동으로 한번만 호출된다.
- **생성자에 리턴 타입을 지정할 수 없다.** (return문은 사용 가능하다.)
- **생성자의 목적은 객체가 생성될 때, 필요한 초기 작업을 위함이다.**

이렇게 생성자는 객체가 생성될 때, <u>필드 초기화, 필요한 메모리 확보, 파일 열기, 네트워크 연결</u> 등 객체가 활동하기 전에 필요한 초기 준비를 하는데 이용된다.

### 기본 생성자

기본 생성자란 매개변수와 실행 코드가 없어 아무 일도 하지 않고 단순 리턴하는 생성자이다. **디폴트 생성자**라고도 부른다.

- 기본 생성자가 자동으로 생성되는 경우 : 생성자가 하나도 없는 경우, 컴파일러는 기본 생성자를 자동으로 생성한다.
- 기본 생성자가 자동으로 생성되지 않는 경우 : 생성자가 하나라도 존재하는 클래스에는 컴파일러가 기본생성자를 자동으로 삽입해 주지 않는다.

### this 레퍼런스

- **this의 기초 개념**

   **this는 현재 객체 자신에 대한 <u>레퍼런스</u>이다.** 보다 정확히 말하면 현재 실행되고 있는 메소드가 속한 객체에 대한 레퍼런스이다. 

- **this의 필요성**

   ```java
   class Circle{
     int radius;
     public Circle(int radius){
       this.radius = radius
     }
   }
   ```

- **객체 자신의 레퍼런스를 리턴해야 하는 경우**

   ```java
   class Circle{
     public Circle getMe(){		//getMe() 메소드는 객체 자신의 레퍼런스를 리턴한다.
       return this;	
     }
   }
   ```

### this()로 다른 생성자 호출

**this()는 클래스 내에서 생성자가 다른 생성자를 호출할 때 사용하는 자바 코드이다.**

- **this() 사용시 주의할 점**
   - this()는 반드시 생성자 코드에서만 호출할 수 있다.
   - this()는 반드시 같은 클래스 내 다른 생성자를 호출할 때 사용된다.
   - this()는 반드시 생성자의 첫 번째 문장이 되어야 한다.

### 객체 치환 시 주의할 점

아무도 가리키지 않는 객체는 **가비지(garbage)**라고 부르며, 가비지는 자바 가상 기계에 의해 자동으로 수거되어 재사용된다.

---

## 4.4 객체 배열

### 객체 배열

자바에서 기본 타입 데이터 뿐 아니라 객체를 원소로 하는 객체 배열도 만들 수 있다.

자바의 **객체 배열**은 **객체에 대한 레퍼런스를 원소로 갖는 배열**이다.

```java
Circle [] c;							//Circle 배열에 대한 레퍼런스 변수 c 선언
c = new Circle[5];				//레퍼런스 배열 생성

for(int i=0;i<c.length;i++)
  c[i] = new Circle(i);		// 배열의 각 원소 객체 생성
```

### 배열 선언 및 생성

1. 배열에 대한 레퍼런스 선언

   ```java
   Circle [] c;
   ```

2. 레퍼런스 배열 생성

   ```java
   c = new Circle[5];	// Circle 객체에 대한 레퍼런스 5개 생성
   ```

3. 객체 생성

4. 객체 사용

---

## 4.5 메소드 활용

### 메소드 형식

**메소드**는 **클래스의 멤버 함수**로서, 메소드 앞에 접근 지정자를 선언한다는 점을 제외하면 C / C++의 함수 작성법과 동일하다.
접근 지정자는 **public, private, protected, 디폴트**의 4가지 유형으로, 메소드가 다른 클래스에서 호출될 수 있는지 지정하기 위해 사용된다.

```java
public int getSum(int i, int j){
  int sum;
  sum = i + j;
  return sum;
}
```

### 인자 전달

자바의 메소드 호출 시 인자 전달 방식(argument passing)은 '**값에 의한 호출(call-by-value)**'이다.
호출하는 실인자의 값이 복사되어 **메소드의 매개 변수에** 전달된다.

- **기본 타입의 값이 전달되는 경우**
   메드의 매개변수가 기본 타입(byte, char, short, int, long, float, double, boolean)으로 선언된 경우, **호출자(caller)**가 건네는 **값이 매개변수에 복사되어** 전달된다.

- **객체가 전달되는 경우**
   메소드의 매개변수가 클래스 타입의 경우, 객체가 아니라 **객체의 레퍼런스 **값이 전달된다.

   ```java
   class Circle{
     int radius;
   }
   public class ReferencePassing{
     static void increase(Circle m){
       m.radius++;
     }
     public static void main(String[] args){
       Circle pizza = new Circle(10);
       
       increase(pizza);	
       
       System.out.println(pizza.radius);
     }
   }
   /*
   호출하는 매개변수 m이 생기고, pizza 변수에 저장된 값(레퍼런스) 이 m에 복사되어, m은 pizza가 가리키는 객체를 
   함께 가리키게 된다.
   */
   ```

   메소드 호출 시 객체가 전달되는 경우, **객체에 대한 레퍼런스만 전달**되지 객체가 통째로 복사되지 않는다는 점을 유념!!

- ****





































